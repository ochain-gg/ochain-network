
/*
 * CometBFT RPC
 *
 * CometBFT supports the following RPC protocols:  * URI over HTTP * JSONRPC over HTTP * JSONRPC over websockets  ## Configuration  RPC can be configured by tuning parameters under `[rpc]` table in the `$CMTHOME/config/config.toml` file or by using the `--rpc.X` command-line flags.  The default RPC listen address is `tcp://127.0.0.1:26657`. To set another address, set the `laddr` config parameter to desired value. CORS (Cross-Origin Resource Sharing) can be enabled by setting `cors_allowed_origins`, `cors_allowed_methods`, `cors_allowed_headers` config parameters.  If testing using a local RPC node, under the `[rpc]` section change the `cors_allowed_origins` property, please add the URL of the site where this OpenAPI document is running, for example:    `cors_allowed_origins = [\"http://localhost:8088\"]`  or if testing from the official documentation site:    `cors_allowed_origins = [\"https://docs.cometbft.com\"]`  ## Arguments  Arguments which expect strings or byte arrays may be passed as quoted strings, like `\"abc\"` or as `0x`-prefixed strings, like `0x616263`.  ## URI/HTTP  A REST like interface.      curl localhost:26657/block?height=5  ## JSONRPC/HTTP  JSONRPC requests can be POST'd to the root RPC endpoint via HTTP.      curl --header \"Content-Type: application/json\" --request POST --data '{\"method\": \"block\", \"params\": [\"5\"], \"id\": 1}' localhost:26657  ## JSONRPC/websockets  JSONRPC requests can be also made via websocket. The websocket endpoint is at `/websocket`, e.g. `localhost:26657/websocket`. Asynchronous RPC functions like event `subscribe` and `unsubscribe` are only available via websockets.  For example using the [websocat](https://github.com/vi/websocat) tool, you can subscribe for 'NewBlock` events with the following command:      echo '{ \"jsonrpc\": \"2.0\",\"method\": \"subscribe\",\"id\": 0,\"params\": {\"query\": \"tm.event='\"'NewBlock'\"'\"} }' | websocat -n -t ws://127.0.0.1:26657/websocket 
 *
 * API version: v0.38.x
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type UnsafeApiService service
/*
UnsafeApiService Add Peers/Persistent Peers (unsafe)
Set a persistent peer, this route in under unsafe, and has to manually enabled to use.  **Example:** curl &#x27;localhost:26657/dial_peers?peers&#x3D;\\[\&quot;f9baeaa15fedf5e1ef7448dd60f46c01f1a9e9c4@1.2.3.4:26656\&quot;,\&quot;0491d373a8e0fcf1023aaf18c51d6a1d0d4f31bd@5.6.7.8:26656\&quot;\\]&amp;persistent&#x3D;false&#x27; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *UnsafeApiDialPeersOpts - Optional Parameters:
     * @param "Persistent" (optional.Bool) -  Have the peers you are dialing be persistent
     * @param "Unconditional" (optional.Bool) -  Have the peers you are dialing be unconditional
     * @param "Private" (optional.Bool) -  Have the peers you are dialing be private
     * @param "Peers" (optional.Interface of []string) -  array of peers to dial
@return DialResp
*/

type UnsafeApiDialPeersOpts struct {
    Persistent optional.Bool
    Unconditional optional.Bool
    Private optional.Bool
    Peers optional.Interface
}

func (a *UnsafeApiService) DialPeers(ctx context.Context, localVarOptionals *UnsafeApiDialPeersOpts) (DialResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DialResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dial_peers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Persistent.IsSet() {
		localVarQueryParams.Add("persistent", parameterToString(localVarOptionals.Persistent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unconditional.IsSet() {
		localVarQueryParams.Add("unconditional", parameterToString(localVarOptionals.Unconditional.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Private.IsSet() {
		localVarQueryParams.Add("private", parameterToString(localVarOptionals.Private.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Peers.IsSet() {
		localVarQueryParams.Add("peers", parameterToString(localVarOptionals.Peers.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DialResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UnsafeApiService Dial Seeds (Unsafe)
Dial a peer, this route in under unsafe, and has to manually enabled to use    **Example:** curl &#x27;localhost:26657/dial_seeds?seeds&#x3D;\\[\&quot;f9baeaa15fedf5e1ef7448dd60f46c01f1a9e9c4@1.2.3.4:26656\&quot;,\&quot;0491d373a8e0fcf1023aaf18c51d6a1d0d4f31bd@5.6.7.8:26656\&quot;\\]&#x27; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *UnsafeApiDialSeedsOpts - Optional Parameters:
     * @param "Peers" (optional.Interface of []string) -  list of seed nodes to dial
@return DialResp
*/

type UnsafeApiDialSeedsOpts struct {
    Peers optional.Interface
}

func (a *UnsafeApiService) DialSeeds(ctx context.Context, localVarOptionals *UnsafeApiDialSeedsOpts) (DialResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DialResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dial_seeds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Peers.IsSet() {
		localVarQueryParams.Add("peers", parameterToString(localVarOptionals.Peers.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DialResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
